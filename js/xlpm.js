/* 
 * 
 * orange.js is written by Islam Akef Ebeid in effort to display the data supplied in the file generated by the XLPM project representing peptide interactions
 * 
 */

unit = 25;
scaleValue = 1;
fileWeight = 0;

function main(fastaFile, dataFile) {
    $("#vis").show();
    var dim = calculateLWSVG(fastaFile);
    var sequence_table = createSequenceTable(fastaFile);
    var sequences = TAFFY(sequence_table);
    var block_table = createBlockTable(dataFile);
    var blocks = TAFFY(block_table.blocks);
    var precursorinfo = TAFFY(block_table.precursorinfo);
    var initObj = init(dim);
    var resultArray = displaySequenceTable(sequence_table, initObj.width, initObj.height);
    var points = createPointsTable(sequences, blocks);
    createDataPointsOnMatrix(resultArray.cellHeigts, resultArray.cellWidths, points.filteredPointsTable, points.points_table, blocks, precursorinfo, "#000099", resultArray.rectHeight, resultArray.rectWidth);
    createSlider();
    d3.select("#mainButton").attr("disabled", "true");
}

function init(svgDim) {
    var width = svgDim.w;
    var height = svgDim.h;
    var svg = d3.select("#vis").append("svg").attr("width", "100%").attr("height", "100%").attr("viewBox", "0 0 " + width + " " + height)
            .attr("preserveAspectRatio", "xMinYMin meet").attr("id", "mainSVG");
    svg.style("font-family", "Helvetica").style("font-size", "10px");
    var gridGroup = svg.append("g").attr("id", "gridGroup");
    var infoGroup = svg.append("g").attr("id", "infoGroup").attr("transform", "translate(" + unit + "," + unit + ")");
    infoGroup.append("g").attr("id", "legendGroup");
    infoGroup.append("g").attr("id", "scaleGroup").attr("transform", "translate(" + 3 * unit + "," + (unit + unit / 2) + ")");
    var visGroup = svg.append("g").attr("id", "visGroup").attr("transform", "translate(" + unit + "," + 5 * unit + ")");
    visGroup.append("g").attr("id", "first");
    visGroup.append("g").attr("id", "second");
    visGroup.append("g").attr("id", "third");
    drawSVG(gridGroup, width, height);
    return {width: width, height: height};
}

//Create main SVG element

function calculateLWSVG(fastaFile) {
    var countValid = 0;
    var firstSeq = "";
    var secondSeq = "";
    var lines = fastaFile.split('\n');
    for (var j = 0; j < lines.length; j++) {
        var line = lines[j];
        line = line.trim();
        if (line.length !== 0) {
            if (line[0] === '>') {
                countValid++;
                continue;
            }
            if (countValid === 1) {
                firstSeq += line;
            }
            if (countValid > 1) {
                secondSeq += line;
            }
        }
    }
    var calculatedHeight = ((secondSeq.length + 2) * 6.78) + 121;
    var calculatedWidth = document.getElementById("vis").clientWidth - 28;
    unit = (calculatedWidth / calculatedHeight) * 1.68 + 20;
    fileWeight = firstSeq.length * secondSeq.length;
    return {w: calculatedWidth, h: calculatedHeight};
}

function drawSVG(gridGroup, width, height) {
    var widthRatio = width / (4.15 * unit);
    var heightRatio = height / (3.9 * unit);
    var data = [];
    for (var k = 0; k < heightRatio; k++) {
        data.push(d3.range(widthRatio));
    }
    var grp = gridGroup.selectAll("g")
            .data(data)
            .enter()
            .append("g")
            .attr("transform", function (d, i) {
                return "translate(0, " + (4 * unit) * i + ")";
            });
    grp.selectAll("rect")
            .data(function (d) {
                return d;
            })
            .enter()
            .append("rect")
            .attr("x", function (d, i) {
                return (4 * unit) * i;
            })
            .attr("width", (4 * unit))
            .attr("height", (4 * unit))
            .style("fill", "#fff")
            .style("stroke", "#ccc")
            .style("stroke-width", "1");
}

function clearSVG() {
    window.location.reload();
}

function minimize(group, x, y, value) {
    var s = Snap(group);
    var g = s;
    var myMatrix = new Snap.Matrix();
    myMatrix.scale(value, value);
    myMatrix.translate(x, y);
    myMatrix.invert();
    g.animate({transform: myMatrix}, 2000, mina.bounce, function () {
        g.animate({transform: myMatrix}, 2000, mina.bounce);
    });
}

function maximize(group, x, y, value) {
    var s = Snap(group);
    var g = s;
    var myMatrix = new Snap.Matrix();
    myMatrix.scale(value, value);
    myMatrix.translate(x, y);
    myMatrix.invert();
    g.animate({transform: myMatrix}, 2000, mina.bounce, function () {
        g.animate({transform: myMatrix}, 2000, mina.bounce);
    });
}

//Parse data from the 2 input files (fasta , spectra data)

function checkForSpecialCharacters(sequence) {
    var specialChars = ["!", "@", "#", "$", "%", "^"];
    var specialCharactersObjectsArray = [{char: "!", rep: "C"}, {char: "@", rep: "C"}, {char: "#", rep: "C"}, {char: "$", rep: "M"}, {char: "%", rep: "N"}, {char: "^", rep: "Q"}];
    var input = sequence.toString();
    var specialCharactersObjectsArrayTaffy = TAFFY(specialCharactersObjectsArray);
    var indecies = [];
    function setCharAt(str, index, chr) {
        var returnStr;
        for (var i = 0; i < str.length; i++) {
            var firsPart = str.substring(0, index);
            var secondPart = str.substring(index + 1, str.length);
            returnStr = firsPart + chr + secondPart;
        }
        return returnStr;
    }
    for (var i = 0; i < input.length; i++) {
        if (specialChars.indexOf(input[i]) !== -1) {
            indecies.push(i);
        }
    }
    var pears = input;
    for (var i = 0; i < indecies.length; i++) {
        var obj = specialCharactersObjectsArrayTaffy({char: input.charAt(indecies[i])}).get();
        pears = setCharAt(pears, indecies[i], obj[0].rep);
    }
    return pears;
}

function createSequenceTable(fastaFile) {
    var sequence_table = [];
    var countValid = 0;
    var counterRelay = 0;
    var firstSeq = "";
    var secondSeq = "";
    var lines = fastaFile.split('\n');
    for (var j = 0; j < lines.length; j++) {
        var line = lines[j];
        line = line.trim();
        if (line.length !== 0) {
            if (line[0] === '>') {
                countValid++;
                continue;
            }
            if (countValid === 1) {
                firstSeq += line;
            }
            if (countValid > 1) {
                secondSeq += line;
            }
        }
    }
    if (firstSeq[firstSeq.length - 1] !== "K") {
        firstSeq = firstSeq + "#K";
    }
    if (secondSeq[secondSeq.length - 1] !== "K") {
        secondSeq = secondSeq + "#K";
    }
    var splitseq1 = firstSeq.match(/([^KR])*[KR]?/g);
    splitseq1.pop();
    for (var i = 0; i < splitseq1.length; i++) {
        if (i === splitseq1.length - 1) {
            var lastElement = splitseq1[i];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq1[i] = splitseq1[i].substring(0, lastElement.length - 2);
            }
        }
        sequence_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), type: 1});
        counterRelay++;
    }
    var splitseq2 = secondSeq.match(/([^KR])*[KR]?/g);
    splitseq2.pop();
    for (var j = 0; j < splitseq2.length; j++) {
        if (j === splitseq2.length - 1) {
            var lastElement = splitseq2[j];
            if (lastElement[lastElement.length - 2] === "#") {
                splitseq2[j] = splitseq2[j].substring(0, lastElement.length - 2);
            }
        }
        sequence_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), type: 2});
        counterRelay++;
    }
    return sequence_table;
}

function createBlockTable(dataFile) {
    var blocks = [];
    var precursorinfo = [];
    var lines = dataFile.split("\n");
    var reactionCounter = 0;
    for (var j = 2; j < lines.length; j++) {
        var line = lines[j];
        if (line.length > 0) {
            if (isNaN(line[0])) {
                var splitseq = line.split("\t");
                var frag1Filtered = checkForSpecialCharacters(splitseq[2].toString().toUpperCase());
                var frag2Filtered = checkForSpecialCharacters(splitseq[3].toString().toUpperCase());
                blocks.push({id: reactionCounter, title: splitseq[0], mz: splitseq[1], fragment1: frag1Filtered.toString(), fragment2: frag2Filtered.toString(), tmass: splitseq[4], amass: splitseq[5], charge: splitseq[6], score: splitseq[7]});
                reactionCounter++;
            }
            else {
                var info = reactionCounter + line;
                var splitinfo = info.split("\t");

                precursorinfo.push({blockId: splitinfo[0], frag1: splitinfo[2], frag2: splitinfo[3], score: splitinfo[4]});
            }
        }
    }
    return {blocks: blocks, precursorinfo: precursorinfo};
}

function createPointsTable(sequences, blocks) {
    var points = [];
    var filteredPoints = [];
    var pointsID = 0;
    function getUniqueNumberForSequence(fragment, sequence, type) {
        var uniqueNumber;
        var seqObject = sequences({sequence: sequence, type: type}).get();
        if (seqObject.length === 0) {
            alert("Data file does not match FASTA file!");
            clearSVG();
            return;
        }
        if (seqObject.length === 1) {
            uniqueNumber = seqObject[0].uniqueNumber;
        }
        if (seqObject.length > 1) {
            seqObject.forEach(function (seqObj, j) {
                var dividedFrag = fragment.toString().toUpperCase().match(/([^KR])*[KR]?/g);
                dividedFrag.pop();
                dividedFrag.forEach(function (seq, i) {
                    if (sequence === seq) {
                        var dividedFragObj = sequences({sequence: dividedFrag[0], type: type}).get();
                        uniqueNumber = dividedFragObj[0].uniqueNumber + i;
                    }
                });
            });
        }
        return uniqueNumber;
    }
    var result = blocks().get();
    result.forEach(function (r) {
        var seqs1 = r.fragment1;
        var splitseq1 = seqs1.match(/([^KR])*[KR]?/g);
        splitseq1.pop();
        var seqs2 = r.fragment2;
        var splitseq2 = seqs2.match(/([^KR])*[KR]?/g);
        splitseq2.pop();
        splitseq1.forEach(function (s1) {
            splitseq2.forEach(function (s2) {
                var sourceNumber = getUniqueNumberForSequence(seqs1.toString().toUpperCase(), s1, 1);
                var targetNumber = getUniqueNumberForSequence(seqs2.toString().toUpperCase(), s2, 2);
                points.push({id: pointsID, blockId: r.id, sequence1: s1, sequence2: s2, score: r.score, sourceNumber: sourceNumber, targetNumber: targetNumber, title: r.title, mz: r.mz, tmass: r.tmass,
                    amass: r.amass, charge: r.charge});
                pointsID++;
            });
        });
    });
    var points_table = TAFFY(points);
    var query2 = points_table().distinct("sequence1", "sequence2");
    query2.forEach(function (element) {
        var elements = points_table({sequence1: element[0], sequence2: element[1]}).get();
        var elements_table = TAFFY(elements);
        var maxScore = elements_table().max("score");
        var pointObj = points_table({sequence1: element[0], sequence2: element[1], score: maxScore}).get();
        var sourceNumber = pointObj[0].sourceNumber;
        var targetNumber = pointObj[0].targetNumber;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(maxScore),
            id: pointObj[0].id, sequence1: pointObj[0].sequence1, sequence2: pointObj[0].sequence2,
            title: pointObj[0].title, mz: pointObj[0].mz, tmass: pointObj[0].tmass,
            amass: pointObj[0].amass, charge: pointObj[0].charge});
    });
    var filteredPointsTable = TAFFY(filteredPoints);
    return {filteredPointsTable: filteredPointsTable, points_table: points_table};
}

//Create the color legend that serves for level 1 and level 2 

function createColorLegend(data) {
    var x1 = 3 * unit,
            barWidth = document.getElementById("vis").offsetWidth - (7 * unit),
            y1 = unit / 1.5,
            barHeight = unit,
            numberHues = data.length;
    var idGradient = "legendGradient";
    var svgForLegendStuff = d3.select("#legendGroup");
    svgForLegendStuff.append("g").attr("id", "firstLegendGroup").append("defs")
            .append("linearGradient")
            .attr("id", idGradient)
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "0%")
            .attr("y2", "0%");
    svgForLegendStuff.append("rect")
            .attr("fill", "url(#" + idGradient + ")")
            .attr("x", x1)
            .attr("y", y1)
            .attr("width", barWidth)
            .attr("height", barHeight);
    var textY = y1 + barHeight / 2 + 5;
    svgForLegendStuff.selectAll(".leftLegend")
            .data(data)
            .enter().append("g")
            .attr("class", "leftLegend").append("text")
            .attr("text-anchor", "middle")
            .attr("x", x1 - 20)
            .attr("y", textY).attr("font-size", "15px")
            .attr("dy", 0)
            .text(function (d, i) {
                if (i === 0) {
                    return d.value.toFixed(2);
                }
                return " ";
            });
    svgForLegendStuff.selectAll(".rightLegend")
            .data(data)
            .enter().append("g")
            .attr("class", "rightLegend").append("text")
            .attr("text-anchor", "left")
            .attr("x", x1 + barWidth + 10)
            .attr("y", textY)
            .attr("font-size", "15px")
            .attr("dy", 0)
            .text(function (d, i) {
                if (i === (data.length - 1)) {
                    return d.value.toFixed(2);
                }
                return " ";
            });
    var hueStart = 160, hueEnd = 0;
    var opacityStart = data[0].opacityValue, opacityEnd = data[data.length - 1].opacityValue;
    var theHue, rgbString, opacity, p;
    var deltaPercent = 1 / (numberHues - 1);
    var deltaHue = (hueEnd - hueStart) / (numberHues - 1);
    var deltaOpacity = (opacityEnd - opacityStart) / (numberHues - 1);
    var theData = [];
    for (var i = 0; i < numberHues; i++) {
        theHue = hueStart + deltaHue * i;
        rgbString = "#000099";
        opacity = opacityStart + deltaOpacity * i;
        p = 0 + deltaPercent * i;
        theData.push({"rgb": rgbString, "opacity": opacity, "percent": p});
    }
    var stops = d3.select('#' + idGradient).selectAll('stop')
            .data(theData);
    stops.enter().append('stop');
    stops.attr('offset', function (d) {
        return d.percent;
    })
            .attr('stop-color', function (d) {
                return d.rgb;
            })
            .attr('stop-opacity', function (d) {
                return d.opacity;
            });
}

function createSlider() {
    var height = unit;
    var width = document.getElementById("vis").offsetWidth - (7 * unit);
    var x = d3.scale.linear().domain([0.1, 1.5]).range([0, width]).clamp(true);
    var brush = d3.svg.brush().x(x).extent([0, 0]).on("brush", brushed);
    var svg = d3.select("#scaleGroup");
    svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height / 2 + ")").call(d3.svg.axis().scale(x).orient("bottom").tickSize(1).tickPadding(10).tickValues([0, 100]));
    var slider = svg.append("g").attr("class", "slider").call(brush);
    slider.selectAll(".extent,.resize").remove();
    slider.select(".background").attr("height", height);
    var handle = slider.append("circle").attr("class", "handle").attr("transform", "translate(0," + height / 2 + ")").attr("r", 5);
    slider.call(brush.event).transition().duration(750).call(brush.extent([70, 70])).call(brush.event);
    function brushed() {
        if (fileWeight > 300) {
            scaleValue = 0.3;
        }
        if (fileWeight < 300) {
            scaleValue = 0.8;
        }
        var value = scaleValue;
        if (d3.event.sourceEvent) {
            value = x.invert(d3.mouse(this)[0]);
            brush.extent([value, value]);
        }
        handle.attr("cx", x(value));
        d3.select("#first").attr("transform", "scale(" + value + ")");
    }
}

//Create first level visualization of the whole spectra data file

function displaySequenceTable(sequence_table, width, height) {
    var rowCount = 0;
    var columnCount = 0;
    var seqOneCount = 0;
    var rowHeaders = [];
    var columnHeaders = [];
    var yCount = 0;
    var xCount = 0;
    var lengthValue = -3;
    var lengthValueText = -3;
    var temp = [];
    var tempText = [];
    temp[0] = 3;
    tempText[0] = 3;
    var cellHeigts = [];
    var computedLengthsArray = [];
    var widthValue = -3;
    var widthValueText = -3;
    var anotherTempText = [];
    anotherTempText[0] = 3;
    var anotherTemp = [];
    anotherTemp[0] = 3;
    var cellWidths = [];
    var computedLengthsArrayColumn = [];
    sequence_table.forEach(function (node) {
        if (node.type === 1) {
            columnCount = columnCount + node.sequence.length;
            columnHeaders[xCount] = node.sequence;
            seqOneCount++;
            xCount++;
        }
        if (node.type === 2) {
            rowCount = rowCount + node.sequence.length;
            rowHeaders[yCount] = node.sequence;
            yCount++;
        }
    });
    var rect = d3.select("#first").append("rect")
            .attr("class", "background")
            .attr("width", width)
            .attr("height", height).attr("fill", "#A9A9A9");
    var row = d3.select("#first").selectAll(".row")
            .data(rowHeaders)
            .enter().append("g")
            .attr("class", "row");
    row.append("text")
            .attr("x", 0)
            .attr("y", 8.272)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArray[i] = this.getComputedTextLength();
        lengthValueText = lengthValueText + tempText[i];
        tempText[i + 1] = computedLengthsArray[i];
        var h = lengthValueText;
        return "translate(0," + h + ")rotate(90)";
    });
    var column = d3.select("#first").selectAll(".column")
            .data(columnHeaders)
            .enter().append("g")
            .attr("class", "column");
    column.append("text")
            .attr("x", 0)
            .attr("y", 12.4)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArrayColumn[i] = this.getComputedTextLength();
        widthValueText = widthValueText + anotherTempText[i];
        anotherTempText[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValueText;
        return "translate(" + w + ",-20)";
    });
    var newWidth;
    var totalWidth = 0;
    computedLengthsArrayColumn.forEach(function (w) {
        totalWidth += w;
    });
    newWidth = totalWidth;
    var newHeight;
    var totalHeight = 0;
    computedLengthsArray.forEach(function (l) {
        totalHeight += l;
    });
    newHeight = totalHeight;
    row.append("line").attr("stroke", "#fff")
            .attr("x2", newWidth).attr("transform", function (d, i) {
        lengthValue = lengthValue + temp[i];
        temp[i + 1] = computedLengthsArray[i];
        var h = lengthValue;
        cellHeigts.push(h);
        return "translate(0," + h + ")";
    });
    column.append("line").attr("stroke", "#fff")
            .attr("x1", -newHeight).attr("transform", function (d, i) {
        widthValue = widthValue + anotherTemp[i];
        anotherTemp[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValue;
        cellWidths.push(w);
        return "translate(" + w + ")rotate(-90)";
    });
    rect.attr("width", newWidth).attr("height", newHeight);
    var cellHeightLastElement = cellHeigts[cellHeigts.length - 1] + computedLengthsArray[computedLengthsArray.length - 1];
    var cellWidthsLastElement = cellWidths[cellWidths.length - 1] + computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
    cellHeigts.push(cellHeightLastElement);
    cellWidths.push(cellWidthsLastElement);
    return {
        cellHeigts: cellHeigts,
        cellWidths: cellWidths,
        rectHeight: newHeight,
        rectWidth: newWidth
    };
}

function createDataPointsOnMatrix(cellHeigts, cellWidths, pointsTaffyObject, points_table, blocks, precursorinfo, color, newHeight, newWidth) {
    var matrix = [];
    var rowCellHeigtsTemp = [];
    rowCellHeigtsTemp[0] = 0;
    var rowCellHeigts = [];
    rowCellHeigts[0] = 0;
    var rowColumnWidthsTemp = [];
    rowColumnWidthsTemp[0] = 0;
    var rowColumnWidths = [];
    rowColumnWidths[0] = 0;
    for (var i = 0; i < cellHeigts.length; i++) {
        matrix[i] = d3.range(cellWidths.length).map(function (j) {
            return {w: 0, h: 0, positionX: 0, positionY: 0, title: '', mz: 0, tmass: 0,
                amass: 0, charge: 0, sequence1: '', sequence2: '', source: 0, target: 0, value: 0};
        });
    }
    var points = pointsTaffyObject().get();
    points.forEach(function (point) {
        matrix[point.target][point.source].title = point.title;
        matrix[point.target][point.source].mz = point.mz;
        matrix[point.target][point.source].tmass = point.tmass;
        matrix[point.target][point.source].amass = point.amass;
        matrix[point.target][point.source].charge = point.charge;
        matrix[point.target][point.source].sequence1 = point.sequence1;
        matrix[point.target][point.source].sequence2 = point.sequence2;
        matrix[point.target][point.source].source = point.target;
        matrix[point.target][point.source].target = point.source;
        matrix[point.target][point.source].value = point.value;
    });
    cellHeigts.forEach(function (height, i) {
        var temp = rowCellHeigtsTemp[i] - height;
        i += 1;
        rowCellHeigtsTemp[i] = height;
        rowCellHeigts[i] = Math.abs(temp);
    });
    cellWidths.forEach(function (width, i) {
        var temp = rowColumnWidthsTemp[i] - width;
        i += 1;
        rowColumnWidthsTemp[i] = width;
        rowColumnWidths[i] = Math.abs(temp);
    });

    rowCellHeigts.shift();
    rowCellHeigts.shift();
    rowColumnWidths.shift();
    rowColumnWidths.shift();
    rowCellHeigtsTemp.shift();
    rowColumnWidthsTemp.shift();
    var existingData = [];
    matrix.forEach(function (d, i) {
        d.forEach(function (cell, j) {
            if (cell.value !== 0) {
                cell.w = rowColumnWidths[j];
                cell.h = rowCellHeigts[i];
                cell.positionX = rowColumnWidthsTemp[j];
                cell.positionY = rowCellHeigtsTemp[i];
                existingData.push(cell);
            }
        });
    });

    var fillOpacities = [];
    var colorSelected = {color: '', opacity: 0};
    var blockArraySorted = existingData.sort(function (a, b) {
        return a.value - b.value;
    });
    var minScore = blockArraySorted[0].value;
    var maxScore = blockArraySorted[blockArraySorted.length - 1].value;
    var z = d3.scale.linear().domain([minScore, maxScore]).range([0.1, 1]);
    existingData.forEach(function (d, i) {
        var fillOpacitiesTaffy;
        d3.select("#first").append("rect")
                .attr("x", d.positionX)
                .attr("y", d.positionY)
                .attr("width", d.w - 1)
                .attr("height", d.h - 1).style("fill", color).style("fill-opacity", function () {
            var opacityValue = z(d.value);
            colorSelected.opacity = opacityValue;
            fillOpacities.push({opacityValue: opacityValue, value: d.value});
            fillOpacitiesTaffy = TAFFY(fillOpacities);
            return opacityValue;
        })
                .on("click", function () {
                    colorSelected.color = color;
                    var opacityObject = fillOpacitiesTaffy({value: d.value}).get();
                    colorSelected.opacity = opacityObject[0].opacityValue;

                    minimize("#first", 0, 0, scaleValue / 3);
                    createTreemap(points_table, d.sequence1, d.sequence2, blocks, precursorinfo, colorSelected);

                })
                .append("title")
                .text("Sequence 1: " + d.sequence1 + "\nSequence 2: " + d.sequence2 + "\nScore: " + d.value);
    });

    function compare(a, b) {
        if (a.value < b.value)
            return -1;
        if (a.value > b.value)
            return 1;
        return 0;
    }
    fillOpacities.sort(compare);
    var flags = [], fillOpacitiesDistinctArray = [], l = fillOpacities.length, i;
    for (i = 0; i < l; i++) {
        if (flags[fillOpacities[i].value])
            continue;
        flags[fillOpacities[i].value] = true;
        fillOpacitiesDistinctArray.push(fillOpacities[i]);
    }
    createColorLegend(fillOpacitiesDistinctArray);
    return existingData;
}

//Create the second level (Occurences of every combination of sequences)

function createTreemap(points, sequence1, sequence2, blocks, precursorinfo, colorSelected) {
    d3.select("#scaleGroup").remove();
    var results = points({sequence1: sequence1, sequence2: sequence2}).get();
    var root = {name: sequence1 + " " + sequence2, children: []};
    results.forEach(function (result) {
        root.children.push({name: "possibility", blockId: result.blockId, size: result.score, amass: result.amass, charge: result.charge, mz: result.mz, sequence1: result.sequence1, sequence2: result.sequence2, title: result.title, tmass: result.tmass});
    });
    var width = 960;
    var height = 600;
    var x = d3.scale.linear().domain([0.3, 1.35]).range([1, 100]).clamp(true);
    var treemap = d3.layout.treemap().size([width, height]).round(true).sticky(true).sort(function (a, b) {
        return a.size - b.size;
    }).value(function (d) {
        return x(d.size);
    });

    var transformYValue = 0;
    var transformXValue = (document.getElementById("first").getBBox().width * 0.1) + (5 * unit);
    var treeMapGroup = d3.select("#second").attr("transform", "translate(" + transformXValue + "," + transformYValue + ")");
    treeMapGroup.append("g").append("text").text(function (d) {
        return sequence1 + " " + sequence2;
    }).attr("transform", function () {
        var textPositionX = (width / 2) - this.getComputedTextLength();
        return "translate(" + textPositionX + ",-10)";
    }).attr("font-size", "20px");
    var cell = treeMapGroup.datum(root).selectAll(".leaf").data(treemap.nodes(root))
            .enter().append("g")
            .attr("class", "leaf")
            .attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
    cell.append("rect")
            .attr("width", function (d) {
                return d.dx;
            })
            .attr("height", function (d) {
                return d.dy;
            })
            .style("fill", function () {
                return colorSelected.color;
            })
            .style("fill-opacity", function () {
                return colorSelected.opacity;
            })
            .style("stroke", "#FFF")
            .style("stroke-width", "2").on("click", function (d) {
        minimize("#second", 0, document.getElementById("first").getBBox().height * 0.4 + 50, 0.3);
        createFinalLevel(blocks, d.blockId, precursorinfo);

    }).append("title")
            .text(function (d) {
                return  "Title: " + d.title + "\n M/Z: " + d.mz + "\n Charge: " + d.charge + "\n T-Mass: " + d.tmass + "\n E-Mass: " + d.amass;
            });
    cell.append("foreignObject")
            .attr("x", 5).attr("y", 5)
            .attr("dx", "1.8em")
            .attr("dy", "1.0em")
            .attr("text-anchor", "middle")
            .attr("font-size", "10px").attr("color", function (d) {
        if (d.size > 0.2) {
            return "#fff";
        }
        else if (d.size < 0.2) {
            return "#000";
        }
    }).attr("width", function (d) {
        return d.dx;
    }).attr("height", function (d) {
        return d.dy;
    })
            .append("xhtml:body")
            .html(function (d) {
                var blockData = blocks({id: d.blockId}).get();
                var textString = "";
                if (blockData.length !== 0) {
                    textString = "<div>" + blockData[0].fragment1 + "</div>" + "<br/><div>" + blockData[0].fragment2 + "</div>" + "<br/><div>" + blockData[0].score + "</div>";
                    return textString;
                }
            }).style("overflow", "hidden");
}

// Display Final Level (Precursor information level)

function createFinalLevel(blocks, blockid, precursorinfo) {
    var blockdata = blocks({id: blockid}).get();
    var precursorinfodata = precursorinfo({blockId: blockid + ""}).get();
    var counterRelay = 0;
    var character_table = [];
    var frag1 = blockdata[0].fragment1;
    var frag2 = blockdata[0].fragment2;
    var splitseq1 = frag1.match(/./g);
    for (var i = 0; i < splitseq1.length; i++) {
        character_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), type: 1});
        counterRelay++;
    }
    var splitseq2 = frag2.match(/./g);
    for (var j = 0; j < splitseq2.length; j++) {
        character_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), type: 2});
        counterRelay++;
    }
    var transformYValue = 0;
    var transformXValue = document.getElementById("first").getBBox().width * 0.2 + document.getElementById("second").getBBox().width * 0.2 + (6 * unit);

    d3.select("#third").attr("transform", "translate(" + transformXValue + "," + transformYValue + ")scale(3)");
    var resultArray = displayCharacterTable(character_table);
    var filteredPoints = [];
    precursorinfodata.forEach(function (info) {
        var sourceNumber = info.frag1 - 1;
        var targetNumber = info.frag2 - 1;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(info.score)});
    });
    var charTableObj = TAFFY(character_table);
    var filteredPointsTaffyObject = TAFFY(filteredPoints);
    createDataPointsOnMatrixForCharacterTable(resultArray.cellHeigts, resultArray.cellWidths, filteredPointsTaffyObject, charTableObj, blocks, precursorinfo, "brown");
    d3.select("#scaleGroup").remove();
}

function displayCharacterTable(character_table) {
    var rowCount = 0;
    var columnCount = 0;
    var seqOneCount = 0;
    var rowHeaders = [];
    var columnHeaders = [];
    var yCount = 0;
    var xCount = 0;
    var lengthValue = -3;
    var lengthValueText = -3;
    var temp = [];
    var tempText = [];
    temp[0] = 3;
    tempText[0] = 3;
    var cellHeigts = [];
    var computedLengthsArray = [];
    var widthValue = -3;
    var widthValueText = -3;
    var anotherTempText = [];
    anotherTempText[0] = 3;
    var anotherTemp = [];
    anotherTemp[0] = 3;
    var cellWidths = [];
    var computedLengthsArrayColumn = [];
    character_table.forEach(function (node) {
        if (node.type === 1) {
            columnCount = columnCount + node.sequence.length;
            columnHeaders[xCount] = node.sequence;
            seqOneCount++;
            xCount++;
        }
        if (node.type === 2) {
            rowCount = rowCount + node.sequence.length;
            rowHeaders[yCount] = node.sequence;
            yCount++;
        }
    });
    var moveY = document.getElementById("first").getBBox().height + 100;
    var rect = d3.select("#third").append("rect")
            .attr("class", "backgroundThrd")
            .attr("width", document.getElementById("second").getBBox().width)
            .attr("height", document.getElementById("second").getBBox().height).attr("fill", "#A9A9A9").on("click", function (d) {
        minimize("#third", 0, moveY, 0.5);
    });
    var row = d3.select("#third").selectAll(".row")
            .data(rowHeaders)
            .enter().append("g")
            .attr("class", "row");
    var rowText = row.append("text")
            .attr("x", function (d) {
                if (d === "I") {
                    return 2.5;
                }
                else {
                    return 0;
                }
            })
            .attr("y", 8)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) {
                return d;
            }).attr("overflow", function (d, i) {
        computedLengthsArray[i] = this.getComputedTextLength();
    });
    var column = d3.select("#third").selectAll(".column")
            .data(columnHeaders)
            .enter().append("g")
            .attr("class", "column");
    var columnText = column.append("text")
            .attr("x", function (d) {
                if (d === "I") {
                    return 2.5;
                }
                else {
                    return 0;
                }
            })
            .attr("y", 12)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d) {
                return d;
            }).attr("overflow", function (d, i) {
        computedLengthsArrayColumn[i] = this.getComputedTextLength();
    });
    computedLengthsArray.sort();
    computedLengthsArrayColumn.sort();
    rowText.attr("transform", function (d, i) {
        lengthValueText = lengthValueText + tempText[i];
        tempText[i + 1] = computedLengthsArray[computedLengthsArray.length - 1];
        var h = lengthValueText;
        return "translate(0," + h + ")rotate(90)";
    });
    columnText.attr("transform", function (d, i) {
        widthValueText = widthValueText + anotherTempText[i];
        anotherTempText[i + 1] = computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
        var w = widthValueText;
        return "translate(" + w + ",-20)";
    });
    var newHeight;
    var totalHeight = 0;
    computedLengthsArray.forEach(function (l) {
        totalHeight += computedLengthsArray[computedLengthsArray.length - 1];
    });
    newHeight = totalHeight;
    var newWidth;
    var totalWidth = 0;
    computedLengthsArrayColumn.forEach(function (w) {
        totalWidth += computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
    });
    newWidth = totalWidth;
    row.append("line").attr("stroke", "#fff")
            .attr("x2", newWidth).attr("transform", function (d, i) {
        lengthValue = lengthValue + temp[i];
        temp[i + 1] = computedLengthsArray[computedLengthsArray.length - 1];
        var h = lengthValue;
        cellHeigts.push(h);
        return "translate(0," + h + ")";
    });
    column.append("line").attr("stroke", "#fff")
            .attr("x1", -newHeight).attr("transform", function (d, i) {
        widthValue = widthValue + anotherTemp[i];
        anotherTemp[i + 1] = computedLengthsArrayColumn[computedLengthsArrayColumn.length - 1];
        var w = widthValue;
        cellWidths.push(w);
        return "translate(" + w + ")rotate(-90)";
    });
    rect.attr("width", newWidth).attr("height", newHeight);
    return {
        cellHeigts: cellHeigts,
        cellWidths: cellWidths,
        rectHeight: newHeight,
        rectWidth: newWidth
    };
}

function createDataPointsOnMatrixForCharacterTable(cellHeigts, cellWidths, pointsTaffyObject, points_table, blocks, precursorinfo, color, newHeight, newWidth) {
    var matrix = [];
    var rowCellHeigtsTemp = [];
    rowCellHeigtsTemp[0] = 0;
    var rowCellHeigts = [];
    rowCellHeigts[0] = 0;
    var rowColumnWidthsTemp = [];
    rowColumnWidthsTemp[0] = 0;
    var rowColumnWidths = [];
    rowColumnWidths[0] = 0;
    for (var i = 0; i < cellHeigts.length; i++) {
        matrix[i] = d3.range(cellWidths.length).map(function (j) {
            return {w: 0, h: 0, positionX: 0, positionY: 0, char1: '', char2: '', source: j, target: i, score: 0};
        });
    }
    var points = pointsTaffyObject().get();
    points.forEach(function (point) {
        matrix[point.target][point.source].score = point.value;
        matrix[point.target][point.source].char1 = points_table({uniqueNumber: point.source, type: 1}).get()[0].sequence;
        matrix[point.target][point.source].char2 = points_table({uniqueNumber: point.target, type: 2}).get()[0].sequence;
    });
    cellHeigts.forEach(function (height, i) {
        var temp = rowCellHeigtsTemp[i] - height;
        i += 1;
        rowCellHeigtsTemp[i] = height;
        rowCellHeigts[i] = Math.abs(temp);
    });
    cellWidths.forEach(function (width, i) {
        var temp = rowColumnWidthsTemp[i] - width;
        i += 1;
        rowColumnWidthsTemp[i] = width;
        rowColumnWidths[i] = Math.abs(temp);
    });
    rowCellHeigts.shift();
    rowCellHeigts.shift();
    rowColumnWidths.shift();
    rowColumnWidths.shift();
    rowCellHeigtsTemp.shift();
    rowColumnWidthsTemp.shift();
    var existingData = [];
    matrix.forEach(function (d, i) {
        d.forEach(function (cell, j) {
            if (cell.score !== 0) {
                cell.w = rowColumnWidths[j];
                cell.h = rowCellHeigts[i];
                cell.positionX = rowColumnWidthsTemp[j];
                cell.positionY = rowCellHeigtsTemp[i];
                existingData.push(cell);
            }
        });
    });
    var fillOpacities = [];
    var colorSelected = {color: '', opacity: 0};
    var blockArraySorted = [];
    var minScore;
    var maxScore;
    if (existingData.length > 1) {
        blockArraySorted = existingData.sort(function (a, b) {
            return a.score - b.score;
        });
        minScore = blockArraySorted[0].score;
        maxScore = blockArraySorted[blockArraySorted.length - 1].score;
    }
    if (existingData.length === 1) {
        minScore = 0;
        maxScore = existingData[0].score;
    }
    if (existingData.length === 0) {
        minScore = 0;
        maxScore = 0;
    }
    var z = d3.scale.linear().domain([minScore, maxScore]).range([0.5, 2]).clamp(true);
    existingData.forEach(function (d, i) {
        d3.select("#third").append("rect")
                .attr("x", d.positionX)
                .attr("y", d.positionY)
                .attr("width", d.w - 1)
                .attr("height", d.h - 1).style("fill", color).style("fill-opacity", function () {
            var opacityValue = z(d.score);
            colorSelected.opacity = opacityValue;
            fillOpacities.push({opacityValue: opacityValue, value: d.score});
            return opacityValue;
        }).append("title")
                .text("Sequence 1: " + d.char1 + "\nSequence 2: " + d.char2 + "\nScore: " + d.score);
    });
    function compare(a, b) {
        if (a.value < b.value)
            return -1;
        if (a.value > b.value)
            return 1;
        return 0;
    }
    fillOpacities.sort(compare);
    createColorLegendForPrecursrData(fillOpacities, color);
    return existingData;
}

function createColorLegendForPrecursrData(data, color) {
    d3.select("#legendGroup").remove();
    d3.select("#scaleGroup").remove();
    var x1 = unit * 2,
            barWidth = document.getElementById("vis").offsetWidth - (7 * unit),
            y1 = unit / 2,
            barHeight = unit,
            numberHues = data.length * 100;
    var idGradient = "legendGradient";
    var svgForLegendStuff = d3.select("#infoGroup");
    svgForLegendStuff.append("g").append("defs")
            .append("linearGradient")
            .attr("id", idGradient)
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "0%")
            .attr("y2", "0%");
    svgForLegendStuff.append("rect")
            .attr("fill", "url(#" + idGradient + ")")
            .attr("x", x1)
            .attr("y", y1)
            .attr("width", barWidth)
            .attr("height", barHeight);
    var textY = y1 + barHeight / 2 + 5;
    svgForLegendStuff.selectAll(".leftLegend")
            .data(data)
            .enter().append("g")
            .attr("class", "leftLegend").append("text")
            .attr("text-anchor", "middle")
            .attr("x", x1 - 20)
            .attr("y", textY).attr("font-size", "15px")
            .attr("dy", 0)
            .text(function (d, i) {
                if (i === 0) {
                    return d.value.toFixed(2);
                }
                return " ";
            });
    svgForLegendStuff.selectAll(".rightLegend")
            .data(data)
            .enter().append("g")
            .attr("class", "rightLegend").append("text")
            .attr("text-anchor", "left")
            .attr("x", x1 + barWidth + 10)
            .attr("y", textY)
            .attr("font-size", "15px")
            .attr("dy", 0)
            .text(function (d, i) {
                if (i === (data.length - 1)) {
                    return d.value.toFixed(2);
                }
                return " ";
            });
    var hueStart = 160, hueEnd = 0;
    var opacityStart = data[0].opacityValue, opacityEnd = data[data.length - 1].opacityValue;
    var theHue, rgbString, opacity, p;
    var deltaPercent = 1 / (numberHues - 1);
    var deltaHue = (hueEnd - hueStart) / (numberHues - 1);
    var deltaOpacity = (opacityEnd - opacityStart) / (numberHues - 1);
    var theData = [];
    for (var i = 0; i < numberHues; i++) {
        theHue = hueStart + deltaHue * i;
        rgbString = color;
        opacity = opacityStart + deltaOpacity * i;
        p = 0 + deltaPercent * i;
        theData.push({"rgb": rgbString, "opacity": opacity, "percent": p});
    }
    var stops = d3.select('#' + idGradient).selectAll('stop')
            .data(theData);
    stops.enter().append('stop');
    stops.attr('offset', function (d) {
        return d.percent;
    })
            .attr('stop-color', function (d) {
                return d.rgb;
            })
            .attr('stop-opacity', function (d) {
                return d.opacity;
            });
}