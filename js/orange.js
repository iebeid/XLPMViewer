/* 
 * 
 * orange.js is written by Islam Akef Ebeid in effort to display the data supplied in the file generated by the XLPM project representing peptide interactions
 * 
 */

                var fastaText = "";
                var dataText = "";
                window.onload = function () {
                    var fastafileInput = document.getElementById('fastafile');
                    fastafileInput.addEventListener('change', function (e) {
                        var file = fastafileInput.files[0];
                        var textType = /fasta.*/;
                        if (file.name.match(textType)) {
                            var reader = new FileReader();
                            reader.onload = function (e) {
                                fastaText = reader.result;
                            }
                            reader.readAsText(file);
                        } else {
                            alert("File not supported!");
                        }
                    });
                    var datafileInput = document.getElementById('datafile');
                    datafileInput.addEventListener('change', function (e) {
                        var file = datafileInput.files[0];
                        var textType = /txt.*/;
                        if (file.name.match(textType)) {
                            var reader = new FileReader();
                            reader.onload = function (e) {
                                dataText = reader.result;
                            }
                            reader.readAsText(file);
                        } else {
                            alert("File not supported!");
                        }
                    });
                }

function main(fastaFile, dataFile) {
    var sequence_table = createSequenceTable(fastaFile);
    var sequences = TAFFY(sequence_table);
    var sequenceVar = sequences().select("id");
    var block_table = createBlockTable(dataFile);
    var blocks = TAFFY(block_table.blocks);
    var precursorinfo = TAFFY(block_table.precursorinfo);
    var svg = init();
    var resultArray = displaySequenceTable(sequence_table,svg);
    var points = createPointsTable(sequences, blocks);
    var drawnPoints = createDataPointsOnMatrix(resultArray.cellHeigts, resultArray.cellWidths, points.filteredPointsTable, svg, points.points_table,blocks,precursorinfo,"blue");
    $("#mainButton").attr("disabled","true");
}

function init(){
        var margin = {top: 80, right: 0, bottom: 10, left: 80};
    var width = 2048;
    var height = 2048;

    var svg = d3.select("section").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .style("margin-left", -margin.left + "px").style("font","10px 'Helvetica Neue'")
            .call( d3.behavior.zoom().scaleExtent([-2, 10]).on("zoom", function () {
                svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
            }))
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    return {svg: svg, width: width, height: height};
}

function createSequenceTable(fastaFile) {
    var sequence_table = [];
    var countValid = 0;
    var counterRelay = 0;
    var firstSeq = "";
    var secondSeq = "";
    var lines = fastaFile.split('\n');
    for (var j = 0; j < lines.length; j++) {
        var line = lines[j];
        if (line[0] === '>') {
            countValid++;
            continue;
        }
        if (countValid === 1) {
            firstSeq = firstSeq + line;
        }
        if (countValid > 1) {
            secondSeq = secondSeq + line;
        }
    }

    var splitseq1 = firstSeq.match(/([^KR])*[KR]?/g);
    splitseq1.pop();

    for (var i = 0; i < splitseq1.length; i++) {
        sequence_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), type: 1});
        counterRelay++;
    }

    var splitseq2 = secondSeq.match(/([^KR])*[KR]?/g);
    splitseq2.pop();

    for (var j = 0; j < splitseq2.length; j++) {
        sequence_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), type: 2});
        counterRelay++;
    }

    return sequence_table;
}

function createBlockTable(dataFile) {
    var blocks = [];
    var precursorinfo = [];
    var lines = dataFile.split('\n');
    var reactionCounter = 0;

    for (var j = 2; j < lines.length; j++) {
        var line = lines[j];
        if (isNaN(line[0])) {
            var splitseq = line.match(/[\S]+/g);
            blocks.push({id: reactionCounter, title: splitseq[0], mz: splitseq[1], fragment1: splitseq[2], fragment2: splitseq[3], tmass: splitseq[4], 
                amass: splitseq[5], charge: splitseq[6], score: splitseq[7]});
            reactionCounter++;
        }
        else{
            var info = reactionCounter + "  " + line;
            var splitinfo = info.match(/[\S]+/g);
            precursorinfo.push({blockId: splitinfo[0], frag1: splitinfo[1], frag2: splitinfo[2], score: splitinfo[3]});
        }
    }
    return {blocks: blocks, precursorinfo: precursorinfo};
}

function createPointsTable(sequences, blocks) {
    var points = [];
    var filteredPoints = [];
    var pointsID = 0;

    function getUniqueNumbers(fragment, type, sequence) {
        var uniqueNumbers = [];
        var correctedUniqueNumber;
        var correctedUniqueNumberTemp;
        var dividedFrag = fragment.toString().toUpperCase().match(/([^KR])*[KR]?/g);
        dividedFrag.pop();
        var result = sequences({sequence: dividedFrag[0], type: type}).get();
        dividedFrag.forEach(function (seq, i) {
            var calcNumber = (result[0].uniqueNumber) + i;
            uniqueNumbers.push({calcNumber: calcNumber, sequence: seq});
        });
        var uniqueNumbersTable = TAFFY(uniqueNumbers);
        correctedUniqueNumberTemp = uniqueNumbersTable({sequence: sequence}).get();
        correctedUniqueNumber = correctedUniqueNumberTemp[0].calcNumber;
        return correctedUniqueNumber;
    }

    var result = blocks().get();
    result.forEach(function (r) {

        var seqs1 = r.fragment1;
        var splitseq1 = seqs1.toString().toUpperCase().match(/([^KR])*[KR]?/g);
        splitseq1.pop();
        var seqs2 = r.fragment2;
        var splitseq2 = seqs2.toString().toUpperCase().match(/([^KR])*[KR]?/g);
        splitseq2.pop();
        splitseq1.forEach(function (s1) {
            splitseq2.forEach(function (s2) {
                var sourceNumber = getUniqueNumbers(seqs1, 1, s1);
                var targetNumber = getUniqueNumbers(seqs2, 2, s2);
                points.push({id: pointsID,blockId: r.id ,sequence1: s1, sequence2: s2, score: r.score, sourceNumber: sourceNumber, targetNumber: targetNumber, title: r.title, mz: r.mz, tmass: r.tmass,
                    amass: r.amass, charge: r.charge});
                pointsID++;
            });
        });
    });

    var points_table = TAFFY(points);

    var query2 = points_table().distinct("sequence1", "sequence2");
    query2.forEach(function (element) {
        var elements = points_table({sequence1: element[0], sequence2: element[1]}).get();
        var elements_table = TAFFY(elements);
        var maxScore = elements_table().max("score");
        var pointObj = points_table({sequence1: element[0], sequence2: element[1], score: maxScore}).get();
        var sourceNumber = pointObj[0].sourceNumber;
        var targetNumber = pointObj[0].targetNumber;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(maxScore),
            id: pointObj[0].id, sequence1: pointObj[0].sequence1, sequence2: pointObj[0].sequence2,
            title: pointObj[0].title, mz: pointObj[0].mz, tmass: pointObj[0].tmass,
            amass: pointObj[0].amass, charge: pointObj[0].charge});
    });
    var filteredPointsTable = TAFFY(filteredPoints);
    return {filteredPointsTable: filteredPointsTable, points_table: points_table};
}

function displaySequenceTable(sequence_table,svg) {
    var rowCount = 0;
    var columnCount = 0;
    var seqOneCount = 0;
    var seqTwoCount = 0;
    var rowHeaders = [];
    var columnHeaders = [];
    var yCount = 0;
    var xCount = 0;
    var lengthValue = -3;
    var lengthValueText = -3;
    var temp = [];
    var tempText = [];
    temp[0] = 3;
    tempText[0] = 3;
    var cellHeigts = [];
    var computedLengthsArray = [];
    var widthValue = -3;
    var widthValueText = -3;
    var anotherTempText = [];
    anotherTempText[0] = 3;
    var anotherTemp = [];
    anotherTemp[0] = 3;
    var cellWidths = [];
    var computedLengthsArrayColumn = [];


 
    sequence_table.forEach(function (node) {
        if (node.type === 1) {
            columnCount = columnCount + node.sequence.length;
            columnHeaders[xCount] = node.sequence;
            seqOneCount++;
            xCount++;
        }
        if (node.type === 2) {
            rowCount = rowCount + node.sequence.length;
            rowHeaders[yCount] = node.sequence;
            yCount++;
        }
    });
    var rect = svg.svg.append("rect")
            .attr("class", "background")
            .attr("width", svg.width)
            .attr("height", svg.height).attr("fill","#A9A9A9");

    var row = svg.svg.selectAll(".row")
            .data(rowHeaders)
            .enter().append("g")
            .attr("class", "row");
    row.append("text")
            .attr("x", 0)
            .attr("y", 8.272)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d, i) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArray[i] = this.getComputedTextLength();
        lengthValueText = lengthValueText + tempText[i];
        tempText[i + 1] = computedLengthsArray[i];
        var h = lengthValueText;
        return "translate(0," + h + ")rotate(90)";
    });
    row.append("line").attr("stroke","#fff")
            .attr("x2", svg.width).attr("transform", function (d, i) {
        lengthValue = lengthValue + temp[i];
        temp[i + 1] = computedLengthsArray[i];
        var h = lengthValue;
        cellHeigts[i] = h;
        return "translate(0," + h + ")";
    });

    var column = svg.svg.selectAll(".column")
            .data(columnHeaders)
            .enter().append("g")
            .attr("class", "column");
    column.append("text")
            .attr("x", 0)
            .attr("y", 12.4)
            .attr("dy", ".32em")
            .attr("text-anchor", "start")
            .text(function (d) {
                return d;
            }).attr("transform", function (d, i) {
        computedLengthsArrayColumn[i] = this.getComputedTextLength();
        widthValueText = widthValueText + anotherTempText[i];
        anotherTempText[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValueText;
        return "translate(" + w + ",-20)";
    });
    column.append("line").attr("stroke","#fff")
            .attr("x1", -svg.height).attr("transform", function (d, i) {
        widthValue = widthValue + anotherTemp[i];
        anotherTemp[i + 1] = computedLengthsArrayColumn[i];
        var w = widthValue;
        cellWidths[i] = w;
        return "translate(" + w + ")rotate(-90)";
    });

    var newWidth;
    var newHeight;
    var totalWidth = 0;
    var totalHeight = 0;
    computedLengthsArray.forEach(function (l) {
        totalHeight += l;
    });
    computedLengthsArrayColumn.forEach(function (w) {
        totalWidth += w;
    });
    newWidth = totalWidth;
    newHeight = totalHeight;
    rect.attr("width", newWidth).attr("height", newHeight);
    console.log(cellHeigts);
    console.log(cellWidths);
    return {
        cellHeigts: cellHeigts,
        cellWidths: cellWidths
    };
}

function createDataPointsOnMatrix(cellHeigts, cellWidths, pointsTaffyObject, svg,points_table,blocks,precursorinfo, color) {
    var matrix = [];
    var rowCellHeigtsTemp = [];
    rowCellHeigtsTemp[0] = 0;
    var rowCellHeigts = [];
    rowCellHeigts[0] = 0;
    var rowColumnWidthsTemp = [];
    rowColumnWidthsTemp[0] = 0;
    var rowColumnWidths = [];
    rowColumnWidths[0] = 0;

    for (var i = 0; i < cellHeigts.length; i++) {
        matrix[i] = d3.range(cellWidths.length).map(function (j) {
            return {x: i, y: j, w: 0, h: 0, positionX: 0, positionY: 0, title: '', mz: 0, tmass: 0,
                amass: 0, charge: 0, sequence1: '', sequence2: '', source: 0, target: 0, value: 0};
        });
    }
    var points = pointsTaffyObject().get();
    
    points.forEach(function (point) {
        console.log(point);
        matrix[point.source][point.target].title = point.title;
        matrix[point.source][point.target].mz = point.mz;
        matrix[point.source][point.target].tmass = point.tmass;
        matrix[point.source][point.target].amass = point.amass;
        matrix[point.source][point.target].charge = point.charge;
        matrix[point.source][point.target].sequence1 = point.sequence1;
        matrix[point.source][point.target].sequence2 = point.sequence2;
        matrix[point.source][point.target].source = point.source;
        matrix[point.source][point.target].target = point.target;
        matrix[point.source][point.target].value = point.value;

    });

    cellHeigts.forEach(function (height, i) {
        var temp = rowCellHeigtsTemp[i] - height;
        i += 1;
        rowCellHeigtsTemp[i] = height;
        rowCellHeigts[i] = Math.abs(temp);
    });
    cellWidths.forEach(function (width, i) {
        var temp = rowColumnWidthsTemp[i] - width;
        i += 1;
        rowColumnWidthsTemp[i] = width;
        rowColumnWidths[i] = Math.abs(temp);
    });
    rowCellHeigts.shift();
    rowCellHeigts.shift();
    rowColumnWidths.shift();
    rowColumnWidths.shift();
    rowCellHeigtsTemp.shift();
    rowColumnWidthsTemp.shift();
    var existingData = [];

    matrix.forEach(function (d, i) {
        d.forEach(function (cell, j) {
            if (cell.value !== 0) {
                cell.w = rowColumnWidths[cell.x];
                cell.h = rowCellHeigts[cell.y];
                cell.positionX = rowColumnWidthsTemp[cell.x];
                cell.positionY = rowCellHeigtsTemp[cell.y];
                existingData[i] = cell;
            }
        });
    });
    var fillOpacities = [];
    var colorSelected = {color: '',opacity: 0};
    var z = d3.scale.linear().domain([0.1, 1.4]).clamp(true);
    existingData.forEach(function (d) {
        var cell = svg.svg.append("rect")
                .attr("x", d.positionX)
                .attr("y", d.positionY)
                .attr("width", d.w - 1)
                .attr("height", d.h - 1).style("fill", color).style("fill-opacity", function(){
                            var opacityValue = z(d.value);
                    colorSelected.opacity = opacityValue;
                            fillOpacities.push(opacityValue);
                            return opacityValue;})
    .on("click", function () {
            colorSelected.color = color;

           // svg.remove();
          // $("svg").empty();
            createTreemap(points_table, d.sequence1, d.sequence2,blocks,precursorinfo,colorSelected,svg);
        })
                .append("title")
                .text("Sequence 1: " + d.sequence1 + "\nSequence 2: " + d.sequence2 + "\nScore: " + d.value);
    });
    fillOpacities.sort();

    /*
d3.select("svg").selectAll("rect")
    .data(fillOpacities)
    .enter().append("rect")
    .style("stroke", "gray")
    .style("fill", "black")
    .attr("height", 40)
    .attr("width", 75);
    */
   svg.svg.append("g").selectAll(".legend").data(fillOpacities)
    .enter().append("rect").attr("class", "legend")
    .style("stroke", "grey")
    .style("fill", color)
    .style("fill-opacity", function(d){return d;})
    .attr("height", 40)
    .attr("width", 75)
    .attr("x", function(d,i){return i * 80;});
   
    
    return existingData;
}

function createTreemap(points, sequence1, sequence2, blocks,precursorinfo,colorSelected,svg) {
    var results = points({sequence1: sequence1, sequence2: sequence2}).get();
    var children = [];
    var root = {name: sequence1 + " " + sequence2, children: []};
    results.forEach(function (result) {
        root.children.push({name: "possibility", blockId: result.blockId, size: result.score, amass: result.amass, charge: result.charge, mz: result.mz, sequence1: result.sequence1, sequence2: result.sequence2, title: result.title, tmass: result.tmass});
    });
    
    var margin = {top: 40, right: 10, bottom: 10, left: 10},
    width = 800 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;
    
////////////////////////////////////////////////////////////////////

     var treemap = d3.layout.treemap()
            .size([width, height])
            .sticky(true)
            .value(function (d) {
                return d.size;
            });

             
                  /*        
  
     d3.select("svg").append("g").selectAll(".leaf").data(treemap.nodes(root))
    .enter().append("g")
            .append("rect")
    .attr("class", "leaf")
    .attr("height", function (d) {return Math.max(0, d.dy - 1) + "px";})
    .attr("width", function (d) {return Math.max(0, d.dx - 1) + "px";})
    .attr("left",function (d) {return d.x + "px";})
    .attr("top",function (d) {return d.y + "px";})
    .attr("y", 50)
    .attr("x", 50)
    .style("fill","grey").style("stroke","black").style("position","absolute");                
    */
   
   
   
   
   
        var cell = svg.svg.append("g").selectAll(".leaf").data(treemap.nodes(root))
    .enter().append("g")
    .attr("class", "leaf")
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

        cell.append("rect")
                .attr("width", function (d) {
                    return d.dx;
                })
                .attr("height", function (d) {
                    return d.dy;
                })
                .style("fill",function(){return colorSelected.color;})
        .style("fill-opacity", function(){return colorSelected.opacity;})
                .style("stroke", "#FFF")
                .style("stroke-width", "1.5").on("click", function (d) {
                createFinalLevel(blocks,d.blockId,precursorinfo,svg);
            });
        
        //cell.append("textarea").attr("width",200).attr("height","auto");
        var textPieces = [];
        var textCell = cell.append("text")
                .attr("x", 0)
                .attr("dx", "1.8em")
                .attr("dy", "1.0em")
                .attr("text-anchor", "middle")
                .attr("font-size", "9px").attr("width","auto").attr("height","auto")
                .text(function (d) {
                    textPieces[0] = d.sequence1;
                    textPieces[1] = d.sequence2;
                    textPieces[2] = d.size;
                    textPieces[3] = d.amass;
                    textPieces[4] = d.charge;
                    textPieces[5] = d.mz;
                    textPieces[6] = d.blockId;
                    //return d.title + "\n" + d.sequence1 + "\n" + d.sequence2 + "\n" + d.size + "\n" + d.amass + "\n" + d.charge + "\n" + d.mz + "\n" + d.blockId;
                    return d.title;
                });
                /*
            textCell.append("tspan").selectAll(".insideText").data(textPieces)
    .enter()
    .attr("class", "insideText").attr("x",0).attr("dy", "1.0em");
                
                */
   

               
            //g.datum(root).selectAll(".node")
            /*
    d3.select("svg").append("g").data(treemap.nodes(root))
  .enter().append("rect")
            .style("left", function (d) {
            return d.x + "px";
        }).style("top", function (d) {
                    return d.y + "px";
                }).style("width", function (d) {
                    return Math.max(0, d.dx - 1) + "px";
                }) .style("height", function (d) {
                    return Math.max(0, d.dy - 1) + "px";
                }).style("border","solid 1px white")
                        .style("font","10px sans-serif")
                        .style("line-height","12px")
                        .style("overflow","hidden")
                        .style("position","absolute")
                        .style("text-indent","2px")
                        .style("background","grey")
            .text(function (d) {
                return d.title + " | " + d.sequence1 + " | " + d.sequence2 + " | " + d.size + " | " + d.amass + " | " + d.charge + " | " + d.mz + " | " + d.blockId;
            }).on("click", function (d) {

       $("svg").empty();
                createFinalLevel(blocks,d.blockId,precursorinfo);
            });
            */
                 
/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
/*
    var color = d3.scale.category20c();

    var treemap = d3.layout.treemap()
            .size([width, height])
            .sticky(true)
            .value(function (d) {
                return d.size;
            });

    var div = d3.select("section").append("div")
            .style("width", (width + margin.left + margin.right) + "px")
            .style("height", (height + margin.top + margin.bottom) + "px")
            .style("left", margin.left + "px")
            .style("top", margin.top + "px");

    var node = div.datum(root).selectAll(".node")
            .data(treemap.nodes)
            .enter().append("div")
            .attr("class", "node")
            .call(position)
            .on("click", function (d) {
                //d3.select("body").remove();
        
                createFinalLevel(blocks,d.blockId,precursorinfo);
            })
            .style("background", function (d) {
                return "grey";
            })
            .text(function (d) {
                return d.title + " | " + d.sequence1 + " | " + d.sequence2 + " | " + d.size + " | " + d.amass + " | " + d.charge + " | " + d.mz + " | " + d.blockId;
            });

    function position() {
        this.style("left", function (d) {
            return d.x + "px";
        })
                .style("top", function (d) {
                    return d.y + "px";
                })
                .style("width", function (d) {
                    return Math.max(0, d.dx - 1) + "px";
                })
                .style("height", function (d) {
                    return Math.max(0, d.dy - 1) + "px";
                });
    }
    */
    /////////////////////////////////////////////////////////////////////
    
}

function createFinalLevel(blocks,blockid,precursorinfo,svg){
    var blockdata = blocks({id: blockid}).get();
    var precursorinfodata = precursorinfo({blockId: blockid+""}).get();
    var counterRelay = 0;
    var character_table = [];
        var frag1 = blockdata[0].fragment1;
        var frag2 = blockdata[0].fragment2;
        
        
         var splitseq1 = frag1.match(/./g);

    for (var i = 0; i < splitseq1.length; i++) {
        character_table.push({id: counterRelay, uniqueNumber: i, sequence: splitseq1[i].toString().toUpperCase(), type: 1});
        counterRelay++;
    }

    var splitseq2 = frag2.match(/./g);

    for (var j = 0; j < splitseq2.length; j++) {
        character_table.push({id: counterRelay, uniqueNumber: j, sequence: splitseq2[j].toString().toUpperCase(), type: 2});
        counterRelay++;
    }
     console.log(character_table);
     var svgElement = d3.select("svg");
    var resultArray = displaySequenceTable(character_table,svgElement);
    
    
    var filteredPoints = [];
    
    precursorinfodata.forEach(function(info){

        var sourceNumber = info.frag1 - 1;
        var targetNumber = info.frag2 - 1;
        filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(info.score)});
    });
    var filteredPointsTaffyObject = TAFFY(filteredPoints);


    var drawnPoints = createDataPointsOnMatrix(resultArray.cellHeigts, resultArray.cellWidths, filteredPointsTaffyObject, svg, character_table,blocks,precursorinfo,"brown");
    
    /*
    filteredPoints.push({source: sourceNumber, target: targetNumber, value: parseFloat(maxScore),
            id: pointObj[0].id, sequence1: pointObj[0].sequence1, sequence2: pointObj[0].sequence2,
            title: pointObj[0].title, mz: pointObj[0].mz, tmass: pointObj[0].tmass,
            amass: pointObj[0].amass, charge: pointObj[0].charge});
            */
}


function clearSVG(){
    //$("#mainButton").attr("disabled","false");
    //$("#mainButton").attr("enabled","true");
    //$("svg").empty();
    window.location.reload();
}



